options
{
  JDK_VERSION = "1.6";
  JAVA_UNICODE_ESCAPE = true;
  STATIC = true;
}

PARSER_BEGIN(SizzleParser)
package sizzle.parser;

public class SizzleParser
{}

PARSER_END(SizzleParser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  < SINGLE_LINE_COMMENT :
    "#" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
//|  < PROTO_STATEMENT :
//    "proto" (~[ "\n", "\r" ])*
//    (
//      "\n"
//    | "\r"
//    | "\r\n"
//    ) >  { if (java.lang.System.currentTimeMillis() > 0) throw new java.lang.RuntimeException(matchedToken.toString().substring(7).replace("\"", "")); }
| < INCLUDE_STATEMENT :
    "include" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) > 
}

TOKEN :
{
  < DOLLAR : "$" >
| < OF : "of" >
| < IF : "if" >
| < DO : "do" >
| < OR : "or" >
| < AND : "and" >
| < ALL : "all" >
| < MAP : "map" >
| < FOR : "for" >
| < NOT : "not" >
| < TYPE : "type" >
| < PROC : "proc" >
| < FILE : "file" >
| < ELSE : "else" >
| < CASE : "case" >
| < SOME : "some" >
| < EACH : "each" >
| < WHEN : "when" >
| < SKIP_ : "skip" >
| < EMIT : "emit" >
| < REST : "rest" >
| < TABLE : "table" >
| < WHILE : "while" >
| < BREAK : "break" >
| < PROTO : "proto" >
| < PROTOX : "protox" >
| < ARRAY : "array" >
| < STATIC : "static" >
| < SWITCH : "switch" >
| < RETURN : "return" >
| < WEIGHT : "weight" >
| < FORMAT : "format" >
| < RESULT : "result" >
| < DEFAULT_ : "default" >
| < CONTINUE : "continue" >
| < SUBMATCH : "submatch" >
| < FUNCTION : "function" >
| < PARSEDMESSAGE : "parsedmessage" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL :
    < BINARY_LITERAL >
  | < OCTAL_LITERAL >
  | < DECIMAL_LITERAL >
  | < HEX_LITERAL > >
| < #BINARY_LITERAL : "0" [ "b", "B" ] ([ "0"-"1" ])+ >
| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >
| < #HEX_LITERAL : "0" [ "x", "X" ] (< HEX_DIGIT_LITERAL >)+ >
| < FLOATING_POINT_LITERAL :
    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< EXPONENT >)? ([ "f", "F", "d", "D" ])?
  | "." ([ "0"-"9" ])+ (< EXPONENT >)? ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ < EXPONENT > ([ "f", "F", "d", "D" ])?
  | ([ "0"-"9" ])+ (< EXPONENT >)? [ "f", "F", "d", "D" ] >
| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >
| < CHARACTER_LITERAL :
    "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        )
      )
    )
    "'" >
| < REGEX_LITERAL : "`" (~[ "`", "\n", "\r" ])* "`" >
| < STRING_LITERAL :
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        )
      )
    )*
    "\"" >
| < #HEX_DIGIT_LITERAL : [ "0"-"9", "a"-"f", "A"-"F" ] >
| < FINGERPRINT_LITERAL : < INTEGER_LITERAL > [ "p", "P" ] >
| < BYTES_LITERAL :
    "B" < STRING_LITERAL >
  | "X" "\"" ( < HEX_DIGIT_LITERAL > < HEX_DIGIT_LITERAL > )* "\"" >
| < TIME_LITERAL :
    < INTEGER_LITERAL > [ "t", "T" ]
  | "T" < STRING_LITERAL > >
}

// Cribbed from the Java 1.1 grammar
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "\u0024", "\u0041"-"\u005a", "\u005f", "\u0061"-"\u007a", "\u00c0"-"\u00d6", "\u00d8"-"\u00f6", "\u00f8"-"\u00ff", "\u0100"-"\u1fff", "\u3040"-"\u318f", "\u3300"-"\u337f", "\u3400"-"\u3d2d", "\u4e00"-"\u9fff", "\uf900"-"\ufaff" ] >
| < #DIGIT : [ "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f", "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f", "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f", "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049" ] >
}

void Start() :
{}
{
  Program() < EOF >
}

// Program = { Declaration | Statement }.
void Program() :
{}
{
  (
    LOOKAHEAD(Declaration())
    Declaration()
  | Statement()
  | Proto()
  )+
}

// Declaration = TypeDecl | StaticVarDecl | VarDecl.
void Declaration() :
{}
{
  TypeDecl()
| StaticVarDecl()
| VarDecl()
}

// TypeDecl = 'type' type_name '=' Type ';'.
// type_name = identifier.
void TypeDecl() :
{}
{
  "type" Identifier() "=" Type() ";"
}

// StaticVarDecl = 'static' VarDecl.
void StaticVarDecl() :
{}
{
  "static" VarDecl()
}

// VarDecl = var_name ':' [Type] ['=' Expression | Block] ';'.
// var_name = identifier.
void VarDecl() :
{}
{
  Identifier() ":"
  [
    LOOKAHEAD(Type())
    Type()
  ]
  [ "=" Expression() | Block() ] ";"
}

// Type =
//   type_name | ArrayType | MapType | TupleType |
//   OutputType | FunctionType | 'proto' Type.
// type_name = identifier.
void Type() :
{}
{
  Identifier()
| ArrayType()
| MapType()
| TupleType()
| OutputType()
| FunctionType()
| "protox" Type()
}

// Component = [component_name ':'] ComponentType.
// component_name = identifier.
// ComponentType = Type.
void Component() :
{}
{
  [
    LOOKAHEAD(Identifier() ":")
    Identifier() ":"
  ]
  Type()
}

// ArrayType = 'array' 'of' Element.
// Element = Component.
void ArrayType() :
{}
{
  "array" "of" Component()
}

// TupleType = SimpleTupleType | ProtoTupleType.
void TupleType() :
{}
{
  LOOKAHEAD(SimpleTupleType())
  SimpleTupleType()
| ProtoTupleType()
}

// SimpleTupleType = '{' [SimpleMemberList] '}'.
void SimpleTupleType() :
{}
{
	"{" [ SimpleMemberList() ] "}"
}

// SimpleMemberList = SimpleMember {',' SimpleMember} [','].
void SimpleMemberList() :
{}
{
  SimpleMember()
  (
    LOOKAHEAD("," SimpleMember())
    "," SimpleMember()
  )*
  [","]
}

// SimpleMember = TypeDecl | StaticVarDecl | SimpleFieldDecl.
// SimpleFieldDecl = Component.
void SimpleMember() :
{}
{
  TypeDecl()
| StaticVarDecl()
| Component()
}

// ProtoTupleType = ['parsedmessage'] '{' [ProtoMemberList] '}'.
void ProtoTupleType() :
{}
{
  [ "parsedmessage" ] "{" [ ProtoMemberList() ] "}"
}

// ProtoMemberList = ProtoMember {',' ProtoMember} [','].
void ProtoMemberList() :
{}
{
  ProtoMember()
  (
    LOOKAHEAD("," ProtoMember())
    "," ProtoMember()
  )*
  [","]
}

// ProtoMember = TypeDecl | StaticVarDecl | ProtoFieldDecl.
void ProtoMember() :
{}
{
  TypeDecl()
| StaticVarDecl()
| ProtoFieldDecl()
}

// ProtoFieldDecl = Component ['=' ProtoFieldDefault] '@' proto_field_tag [':' proto_field_type].
// ProtoFieldDefault = Expression.
// proto_field_tag = integer.
// proto_field_type = identifier.
void ProtoFieldDecl() :
{}
{
  Component() [ "=" Expression() ] "@" Identifier() [ ":" Identifier() ]
}

// MapType = 'map' '[' Key ']' 'of' Value.
// Key = Component.
// Value = Component.
void MapType() :
{}
{
  "map" "[" Component() "]" "of" Component()
}

// OutputType =
//   'table' table_type [Parameter] {Index} 'of' Element [Weight]
//   [FileSpec | ProcSpec ] [FormatSpec].
// table_type = identifier.
// Parameter = '(' Expression ')'.
// Index = '[' Component ']'.
// Element = Component.
// Weight = 'weight' Component.
// FileSpec = 'file' '(' ArgumentList ')'.
// ProcSpec = 'proc' '(' ArgumentList ')'.
// FormatSpec = 'format' '(' ArgumentList ')'.
// ArgumentList = ExprList.
void OutputType() :
{}
{
  "table" Identifier() [ "(" ExprList() ")" ]
  (
    "[" Component() "]"
  )*
  "of" Component()
  [
    LOOKAHEAD("weight" Component())
    "weight" Component()
  ]
  [
    "file" "(" ExprList() ")" 
  | "proc" "(" ExprList() ")"
  ]
  [ "format" "(" ExprList() ")" ]
}

// ExprList = Expression {',' Expression }.
void ExprList() :
{}
{
  Expression()
  (
    "," Expression()
  )*
}

// FunctionType = 'function' '(' [ParameterList] ')' [ResultSpec].
// ParameterList = Parameter {',' Parameter}.
// Parameter = identifier ':' Type.
// ResultSpec = ':' Type.
void FunctionType() :
{}
{
  "function" "(" [
    Identifier() ":" Type()
    (
      "," Identifier() ":" Type()
    )*
  ] ")"
  [ ":" Type() ]
}

// Statement =
//   Assignment | Block | BreakStatement | ContinueStatement | DoStatement |
//   EmitStatement | ExprStatement | ForStatement | IfStatement | ResultStatement |
//   ReturnStatement | SwitchStatement | WhenStatement | WhileStatement.
void Statement() :
{}
{
  LOOKAHEAD(Assignment())
  Assignment()
| LOOKAHEAD(Block())
  Block()
| BreakStatement()
| ContinueStatement()
| DoStatement()
| EmitStatement()
| ExprStatement()
| ForStatement()
| IfStatement()
| ResultStatement()
| ReturnStatement()
| SwitchStatement()
| WhenStatement()
| WhileStatement()
}

// Assignment = Factor '=' Expression ';'
void Assignment() :
{}
{
  Factor() "=" Expression() ";"
}

// Block = '{' { Declaration | Statement } '}'.
void Block() :
{}
{
  "{"
  (
    LOOKAHEAD(Declaration())
    Declaration()
  | Statement()
  )*
  "}"
}

// BreakStatement = 'break'.
void BreakStatement() :
{}
{
  "break"
}

// ContinueStatement = 'continue'.
void ContinueStatement() :
{}
{
  "continue"
}

// DoStatement = 'do' Statement 'while' '(' Expression ')' ';'.
void DoStatement() :
{}
{
  "do" Statement() "while" "(" Expression() ")" ";"
}

// EmitStatement = 'emit' OutputDesignator '<-' Expression ['weight' Expression] ';'.
// OutputDesignator = var_name {'[' Expression ']'}.
void EmitStatement() :
{}
{
  "emit" Identifier() (
    "[" Expression() "]"
  )* "<-" Expression() [ "weight" Expression() ] ";"
}

// ExprStatement = Expression [ '++' | '--' ] ';'.
void ExprStatement() :
{}
{
  Expression() [ "++" | "--" ] ";"
}

// ForStatement =
//   'for' '(' [ForDeclExpr] ';' [Expression] ';' [ForDeclExpr] ')' Statement.
// ForDeclExpr = Declaration | ExprStatement.
void ForStatement() :
{}
{
  "for" "(" 
  [
    LOOKAHEAD(ForVarDecl())
    ForVarDecl()
  | ForExprStatement()
  ]
  ";"
  [ Expression() ] 
  ";"
  [
    LOOKAHEAD(ForVarDecl())
    ForVarDecl()
  | ForExprStatement()
  ]
  ")"
  Statement()
}

// needed for the lack of semicolons
void ForVarDecl() :
{}
{
  Identifier() ":"
  [
    LOOKAHEAD(Type())
    Type()
  ]
  [ "=" Expression() | Block() ]
}

// needed for the lack of semicolons

void ForExprStatement() :
{}
{
  Expression() [ "++" | "--" ]
}

// IfStatement = 'if' '(' Expression ')' Statement ['else' Statement].
void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" "(" Expression() ")" Statement()
  [
    LOOKAHEAD(1)
    "else" Statement()
  ]
}

// ResultStatement = 'result' Expression.
void ResultStatement() :
{}
{
  "result" Expression()
}

// ReturnStatement = 'return' [ Expression ].
void ReturnStatement() :
{}
{
  "return" [ Expression() ] ";"
}

// SwitchStatement = 'switch' '(' Expression ')' '{' { Case } Default '}'.
// Case = 'case' CaseLabelList ':' StatementList.
// CaseLabelList = Expression {',' Expression}.
// StatementList = Statement { Statement }.
// Default = 'default' ':' StatementList.
void SwitchStatement() :
{}
{
  "switch" "(" Expression() ")" "{"
  (
    "case" Expression()
    (
      "," Expression()
    )*
    ":" Statement()
    (
      Statement()
    )*
  )*
  "default" ":" Statement()
  (
    Statement()
  )* "}"
}

// WhenStatement = 'when' '(' {QuantifierDecl} Expression ')' Statement.
// QuantifierDecl = var_name ':' quantifier Type ';'.
// quantifier = 'all' | 'each' | 'some'.
void WhenStatement() :
{}
{
  "when" "("
  (
    LOOKAHEAD(IdentifierList() ":")
    IdentifierList() ":"
    (
      "all"
    | "each"
    | "some"
    )
    Type() ";"
  )*
  Expression() ")" Statement()
}

// nonstandard but necessary for a program in "Interpreting the Data"
void IdentifierList() :
{}
{
  Identifier()
  (
    "," Identifier()
  )*
}

// WhileStatement = 'while' '(' Expression ')' Statement.
void WhileStatement() :
{}
{
  "while" "(" Expression() ")" Statement()
}

// Expression = Conjunction {('||' | 'or') Conjunction}.
void Expression() :
{}
{
  Conjunction()
  (
    (
      "||"
    | "or"
    )
    Conjunction()
  )*
}

// Conjunction = Comparison {('&&' | 'and') Comparison}.
void Conjunction() :
{}
{
  Comparison()
  (
    (
      "&&"
    | "and"
    )
    Comparison()
  )*
}

// Comparison = SimpleExpr [relation SimpleExpr].
// relation = '==' | '!=' | '<' | '<=' | '>' | '>='.
void Comparison() :
{}
{
  SimpleExpr()
  [
    (
      "=="
    | "!="
    | "<"
    | "<="
    | ">"
    | ">="
    )
    SimpleExpr()
  ]
}

// SimpleExpr = Term {add_operator Term}.
// add_operator = '+' | '-' | '|' | '^'.
void SimpleExpr() :
{}
{
  Term()
  (
    (
      "+"
    | "-"
    | "|"
    | "^"
    )
    Term()
  )*
}

// Term = Factor {mul_operator Factor}.
// mul_operator = '*' | '/' | '%' | '<<' | '>>' | '&'.
void Term() :
{}
{
  Factor()
  (
    (
      "*"
    | "/"
    | "%"
    | "<<"
    | ">>"
    | "&"
    )
    Factor()
  )*
}

// Factor = Operand { Selector | Index | Call | SawCall }.
void Factor() :
{}
{
  Operand()
  (
    Selector()
  | Index()
  | Call()
//  | SawCall()
  )*
}

// Selector = '.' field_name.
// field_name = identifier.
void Selector() :
{}
{
  "." Identifier()
}

// Index = '[' Expression [':' Expression] ']'.
void Index() :
{}
{
  "[" Expression() [ ":" Expression() ] "]"
}

// Call = '(' ArgumentList ')'.
void Call() :
{}
{
  "(" [ ExprList() ] ")"
}

// SawCall =
//   '(' [IterationCount ','] InputString
//   ',' RegexpList [',' 'rest' Factor] ')'.
// IterationCount = Expression.
// InputString = Expression.
// saw_name = identifier.???
//void SawCall() :
//{}
//{
//  "(" [ Expression() "," ] Expression() "," RegexpList() [ "," "rest" Factor() ] ")"
//}

// RegexpList = Regexp {',' Regexp}.
void RegexpList() :
{}
{
  Regexp()
  (
    LOOKAHEAD("," Regexp())
    "," Regexp()
  )*
}

// Regexp = ['skip'] ['submatch'] string.
void Regexp() :
{}
{
  [ "skip" ] [ "submatch" ] StringLiteral() 
}

// Operand =
//   identifier | literal | Composite | Function | unary_operator Factor |
//   '$' | StatementExpr | '(' Expression ')'.
// unary_operator = '+' | '-' | '~' | '!' | 'not'.
void Operand() :
{}
{
  LOOKAHEAD(Identifier())
  Identifier()
| StringLiteral()
| IntegerLiteral()
| FloatingPointLiteral()
| LOOKAHEAD(Composite())
  Composite()
| Function()
| (
    "+"
  | "-"
  | "~"
  | "!"
  | "not"
  )
  Factor()
| "$"
| StatementExpr()
| "(" Expression() ")"
}

// Composite = '{' [ExprList | PairList | ':'] '}'.
void Composite() :
{}
{
 "{"
    [
      LOOKAHEAD(Pair())
      PairList()
    | ExprList()
    | ":"
    ]
 "}"
}

// PairList = Pair {',' Pair}.
void PairList() :
{}
{
  Pair()
  (
    "," Pair()
  )*
}

// Pair = Expression ':' Expression.
void Pair() :
{}
{
  Expression() ":" Expression()
}

// Function = Type Block.
void Function() :
{}
{
  Type() Block()
}

// StatementExpr = '?' Block .
void StatementExpr() :
{}
{
  "?" Block()
}

// Include = 'include' file_name.
// file_name = string.
//void Include() :
//{}
//{
//  "include" StringLiteral()
//}

// Proto = 'proto' file_name.
// file_name = string.
void Proto() :
{}
{
  "proto" StringLiteral()
}

// identifier = (letter | '_') {letter | '_' | digit}.
// letter = 'A' .. 'Z' | 'a' .. 'z'.
// digit = '0' .. '9'.
void Identifier() :
{}
{
  < IDENTIFIER >
}

// integer = ['-'] (binary_int | octal_int | decimal_int | hexadecimal_int).

// binary_int = '0' ('B' | 'b') bin_digit {bin_digit}.
// octal_int = '0' oct_digit {oct_digit}.
// decimal_int = dec_digit {dec_digit}.
// hexadecimal_int = '0' ('X' | 'x') hex_digit {hex_digit}.

// bin_digit = '0' .. '1'.
// oct_digit = '0' .. '7'.
// dec_digit = '0' .. '9'.
// hex_digit = '0' .. '9' | 'A' .. 'F' | 'a' .. 'f'.
void IntegerLiteral() :
{}
{
  < INTEGER_LITERAL >
}


// fingerprint = integer ('P' | 'p').
void FingerprintLiteral() :
{}
{
  < FINGERPRINT_LITERAL >
}


// floating_point = ['-'] [integer_part]['.' [fraction_part]] [scale_factor].
// 
// integer_part = decimal_int.
// fraction_part = decimal_int.
// scale_factor = ('E' | 'e') ['+'|'-'] exponent.
// exponent = decimal_int.
void FloatingPointLiteral() :
{}
{
  < FLOATING_POINT_LITERAL >
}

// char = ''' character '''.
// character = ordinary_character | escaped_character.
// escaped_character =
//   '\' oct_digit [oct_digit [oct_digit]] |
//   '\' 'x' hex_digit {hex_digit} |
//   '\' 'u' hex_digit hex_digit hex_digit hex_digit |
//   '\' 'U' hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit |
//   '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' | '"') |
//   '\' ordinary_character.
void CharLiteral() :
{}
{
  < CHARACTER_LITERAL >
}

// string = '"' {character} '"' | '`' {character} '`'.
void StringLiteral() :
{}
{
  < STRING_LITERAL >
  | < REGEX_LITERAL >
}

// bytes = 'B' string | 'X' hex_string.
// hex_string = '"' { hex_digit hex_digit } '"' .
void BytesLiteral() : 
{}
{
  < BYTES_LITERAL >
}

// time = integer ('T' | 't') | 'T' string.
void TimeLiteral() :
{}
{
  < TIME_LITERAL >
}
